######################################
# models.py                          #
# for CIM v1.5                       #
# this will be an autogenerated file #
######################################

from django.db import models

from django_cim_forms.models import *

################
# enumerations #
################

class HorizontalGridDiscretizationType_enumeration(MetadataEnumeration):
   _enum = ["logically rectangular","structured triangular","unstructured triangular","unstructured polygonal","pixel-based catchment","composite","spherical harmonics"]

class CompositeGridType_enumeration(MetadataEnumeration):
   _enum = ["yin yang", "icosohedral"]

class LogicallyRectangularGridType_enumeration(MetadataEnumeration):
   _enum = ["latitude-longitude", "regular gaussian","displaced pole","tripolar","cubed sphere"]

class StructuredTriangularGridType_enumeration(MetadataEnumeration):
   _enum = ["icosohedral"]

class UnstructuredPolygonalGridType_enumeration(MetadataEnumeration):
   _enum = ["reduced gaussian"]

class VerticalGridDomain_enumeration(MetadataEnumeration):
   _enum = ["atmospheric","oceanic"]

class DataPurpose_enumeration(MetadataEnumeration):
   _enum = ["ancillaryFile","initialCondition","boundaryCondition"]

class CouplingFrameworkType_enumeration(MetadataEnumeration):
   _enum = ["BFG","ESMF","OASIS"]

class ResponsiblePartyRole_enumeration(MetadataEnumeration):
   _enum = ["Metadata Author","Principle Investigator",]

class ModelComponentType_enumeration(MetadataEnumeration):
    _enum = [ "Advection", "Aerosol3D", "Aerosol2D", "AerolEmissionAndConc", "AerosolKeyProperties", "AerosolModel", "Aerosols", "AerosolSpaceConfig", "AerosolTransport", "AtmChem2D", "AtmChem3D", "AtmChemEmissionAndConc", "AtmChemKeyProperties", "AtmChemSpaceConfig", "AtmChemTransport", "AtmGasPhaseChemistry", "AtmHeterogeneousChemistry", "AtmosAdvection", "AtmosCloudScheme", "AtmosConvectTurbulCloud", "AtmosDynamicalCore", "AtmosHorizontalDomain", "AtmosKeyProperties", "AtmosOrographyAndWaves", "Atmosphere", "AtmosphericChemistry", "AtmosRadiation", "AtmosSpaceConfiguration", "Climate", "CloudSimulator", "IceSheetDynamics", "LandIce", "LandIceGlaciers", "LandIceKeyProperties", "LandIceSheet", "LandIceShelves", "LandIceShelvesDynamics", "LandSurface", "LandSurfaceAlbedo", "LandSurfaceCarbonCycle", "LandSurfaceEnergyBalance", "LandSurfaceKeyProperties", "LandSurfaceLakes", "LandSurfaceSnow", "LandSurfaceSoil", "LandSurfaceSpaceConfiguration", "LandSurfaceVegetation", "LandSurfSoilHeatTreatment", "LandSurfSoilHydrology", "Ocean", "OceanAdvection", "OceanBioBoundaryForcing", "OceanBioChemistry", "OceanBioGasExchange", "OceanBioGeoChemistry", "OceanBioKeyProperties", "OceanBioSpaceConfig", "OceanBioTimeStepFramework", "OceanBioTracers", "OceanBioTracersEcosystem", "OceanBoundaryForcing", "OceanBoundaryForcingTracers", "OceanHorizontalDomain", "OceanInteriorMixing", "OceanKeyProperties", "OceanLateralPhysics", "OceanLateralPhysMomentum", "OceanLateralPhysTracers", "OceanMixedLayer", "OceanNudging", "OceanSpaceConfiguration", "OceanUpAndLowBoundaries", "OceanVerticalPhysics", "PhotoChemistry", "RiverRouting", "SeaIce", "SeaIceDynamics", "SeaIceKeyProperties", "SeaIceSpaceConfiguration", "SeaIceThermodynamics", "StratosphericHeterChem", "TopOfAtmosInsolation", "ToposphericHeterChem", "VegetationCarbonCycle",]

class TimingUnits_enumeration(MetadataEnumeration):
    _enum = ["seconds", "minutes", "hours", "days", "months", "years", "decades", "centuries"]

class LogicalRelationshipType_enumeration(MetadataEnumeration):
    _enum = ['AND','OR','XOR']

class ActivityProject_enumeration(MetadataEnumeration):
    _enum = ['CMIP5','AMIP','TAMIP', 'CASCADE', "DCMIP-2012"]

class CalendarUnitType_enumeration(MetadataEnumeration):
    _enum = ['days','months','years']

class NumericalRequirementType_enumeration(MetadataEnumeration):
    _enum = ['Initial Condition','Boundary Condition','Output Requirement','SpatioTemporal Constraint']

class ConnectionType_enumeration(MetadataEnumeration):
    _enum = ['CCSM Flux Coupler','ESMF','FMS','Files','MCT','OASIS3','OASIS4','Shared Memory','Embedded']

class SpatialRegriddingDimensionType_enumeration(MetadataEnumeration):
    _enum = ['1D','2D','3D']

class SpatialRegriddingStandardMethodType_enumeration(MetadataEnumeration):
    _enum = ['linear','near-neighbour','cubic','conservative-first-order','conservative-second-order','conservative','non-conservative']

class TimeMappingType_enumeration(MetadataEnumeration):
    _enum = ['TimeAccumulation','TimeAverage','LastAvailable','TimeInterpolation','Exact']

class ConformanceType_enumeration(MetadataEnumeration):
    _enum = ['not conformant','standard config','via inputs','via model mods','combination']

class FrequencyType_enumeration(MetadataEnumeration):
    _enum = ['daily','monthly','yearly','hourly']


class DataStatusType_enumeration(MetadataEnumeration):
    _enum = ['complete','metadataOnly','continuouslySupplemented']

class DataHierarchyType_enumeration(MetadataEnumeration):
    _enum = ['run','stream','institute','model','product','experiment','frequency','realm','variable','ensembleMember']

class ComponentLanguageType_enumeration(MetadataEnumeration):
    _enum = ['Fortran','C/C++','Hybrid (Fortran and C/C++)']

class GridType_enumeration(MetadataEnumeration):
    _enum = ["cubed_sphere","displaced_pole","icosahedral_geodesic","reduced_gaussian","regular_lat_lon","spectral_gaussian","tripolar","yin_yang","composite",]

class UnitType_enumeration(MetadataEnumeration):
    _enum = ["meter","hectopascal","pascal","sigma","degrees"]

class DataFormatType_enumeration(MetadataEnumeration):
    _enum = ["Excel","HDF","NetCDF","GRIB 1","GRIB 2","PP","ASCII","HDF EOS","ENCEP ON29","ENCEP ON129","Binary"]

class DataAccessType_enumeration(MetadataEnumeration):
    _enum = ["CD-ROM","DISCDB","DVD","Microfiche","OnlineFileHTTP","OnlineFileFTP"]

class DataRestrictionScopeType_enumeration(MetadataEnumeration):
    _enum = ["metadataAccessConstraint","metadataUseConstraint","dataAccessConstraint","dataUseConstraint"]

###############################
# now onto the actual classes #
###############################

class DataSource(MetadataModel):

    class Meta:
        abstract = False#True

    _name = "DataSource"
    _title = "Data Source"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    purpose = MetadataEnumerationField(enumeration="cim_1_5.DataPurpose_enumeration",open=False,blank=True)

    def __init__(self,*args,**kwargs):
        super(DataSource,self).__init__(*args,**kwargs)

    def __unicode__(self):
        name = u'%s' % self._title
        if self.purpose:
            name = u'%s: %s' % (name,self.purpose)
        return name


class Calendar(MetadataModel):

    _name = "Calendar"
    _title = "Calendar"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    units = MetadataEnumerationField(enumeration="cim_1_5.CalendarUnitType_enumeration",open=False,blank=True)
    length = MetadataAtomicField.Factory("integerfield",blank=True,null=True)
    description = MetadataAtomicField.Factory("textfield",blank=True)
    range = MetadataManyToOneField(sourceModel="cim_1_5.Calendar",targetModel="cim_1_5.DateRange",blank=True,addMode=FieldAddModes.INLINE)


    def __init__(self, *args, **kwargs):
        super(Calendar, self).__init__(*args, **kwargs)
        # IF ANY MODELS ARE TO HAVE SUBTABS,
        # I JUST HAVE TO REGISTER A NEW FIELDTYPE LIKE THIS:
        self.registerFieldType(FieldType("BASIC","Basic Calendar Properties"), ["units","length","range","description"])
        # I CAN ADD AS MANY AS I WANT
        #self.registerFieldType(FieldType("OTHER","Other Properties"),["units","range"])


class DateRange(MetadataModel):
    _name = "DateRange"
    _title = "Date Range"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    duration = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)
    startDate = MetadataAtomicField.Factory("datefield",blank=True,null=True)
    endDate = MetadataAtomicField.Factory("datefield",blank=True,null=True)

    def __init__(self,*args,**kwargs):
        super(DateRange,self).__init__(*args,**kwargs)

class Activity(MetadataModel):
    class Meta:
        abstract = True

    _name = "Activity"
    _title = "Activity"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    project = MetadataEnumerationField(enumeration="cim_1_5.ActivityProject_enumeration",open=True)
    project.help_text = "The project that this activity is associated with"

    def __init__(self, *args, **kwargs):
        super(Activity, self).__init__(*args, **kwargs)
        self.registerFieldType(FieldType("BASIC","Basic Properties"), ["project",])


class NumericalRequirement(MetadataModel):

    _name = "NumericalRequirement"
    _title = "Numerical Requirement"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}


    requirementId = MetadataAtomicField.Factory("charfield",max_length=LIL_STRING,blank=False)
    name = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    type = MetadataEnumerationField(enumeration="cim_1_5.NumericalRequirementType_enumeration",open=False)
    description = MetadataAtomicField.Factory("textfield",blank=True)
#    sources = MetadataDocumentField("DataObject",modelName="dataobject",blank=True,null=True)

    def __init__(self,*args,**kwargs):
        super(NumericalRequirement,self).__init__(*args,**kwargs)

    def __unicode__(self):
        name = self._title
        if self.name:
            name = u'%s: %s' % (name, self.name)
        return name

class CompositeNumericalRequirement(NumericalRequirement):
    _name = "CompositeNumericalRequirement"
    _title = "Numerical Requirement"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    isComposite = MetadataAtomicField.Factory("booleanfield",blank=True)
    isComposite.enables = ["requirementOptions",]
    isComposite.help_text = "is this requirement composed of other child requirements?"

    requirementOptions = MetadataManyToManyField(sourceModel="cim_1_5.CompositeNumericalExperiment",targetModel="cim_1_5.RequirementOption")
    requirementOptions.verbose_name = "sub-requirements"

    def __unicode__(self):
        name = self._title
        if self.name:
            name = u'%s: %s' % (name, self.name)
        return name

    def __init__(self,*args,**kwargs):
        super(CompositeNumericalRequirement,self).__init__(*args,**kwargs)
        self.setInitialValues({"isComposite":False})

class RequirementOption(MetadataModel):
    _name = "RequirementOption"
    _title = "Requirement Option"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}


    optionRelationship = MetadataEnumerationField(enumeration="cim_1_5.LogicalRelationshipType_enumeration")
    optionRelationship.help_text = "Describes how this optional (child) requirement is related to its sibling requirements.  For example, a NumericalRequirement could consist of a set of optional requirements each with an \"OR\" relationship meaning use this boundary condition _or_ that one."
    requirement = MetadataManyToOneField(sourceModel="cim_1_5.RequirementOption",targetModel="cim_1_5.NumericalRequirement")
    requirement.help_text = "A NumericalRequirement that is being used as a set of related requirements; For example if a requirement is to use 1 of 3 boundary conditions, then that \"parent\" requirement would have three \"child\" RequirmentOptions (each of one with the XOR optionRelationship)."

    def __unicode__(self):
        name = self._title
#        if self.optionRelationship:
#            name = u'%s: %s' % (name, self.type)
        if self.requirement:
            name = u'%s: %s' % (name, self.requirement)
        return name

    def __init__(self,*args,**kwargs):
        super(RequirementOption,self).__init__(*args,**kwargs)
 
class Experiment(Activity):
    class Meta:
        abstract = True

    def __init__(self, *args, **kwargs):
        super(Experiment, self).__init__(*args, **kwargs)

# TODO:
#@cim_document
class NumericalExperiment(Experiment):

    _name = "NumericalExperiment"
    _title = "Numerical Experiment"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    shortName = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    longName = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING)
    description = MetadataAtomicField.Factory("textfield",blank=True)
    experimentID = MetadataAtomicField.Factory("charfield",blank=False)
    calendar = MetadataManyToOneField(sourceModel="cim_1_5.NumericalExperiment",targetModel="cim_1_5.Calendar",blank=True,addMode=FieldAddModes.INLINE)
    calendar.help_text = "here is some help text"
    calendar.addMode = FieldAddModes.REMOTE
    numericalRequirements = MetadataManyToManyField(sourceModel="cim_1_5.NumericalExperiment",targetModel="cim_1_5.CompositeNumericalRequirement")


    def __init__(self,*args,**kwargs):
        super(NumericalExperiment,self).__init__(*args,**kwargs)

        self.registerFieldType(FieldType("EXPERIMENT_DESCRIPTION","Experiment Description"),["shortName","longName","experimentID","description","project"])
        self.registerFieldType(FieldType("BASIC","Basic Properties"), ["calendar"])
        self.registerFieldType(FieldType("REQUIREMENTS","Numerical Requirements"), ["numericalRequirements"])
        self.setFieldTypeOrder(["EXPERIMENT_DESCRIPTION","BASIC","REQUIREMENTS",])

class TimeTransformation(MetadataModel):
    _name = "TimeTransformation"
    _title = "Time Transformation"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    mappingType = MetadataEnumerationField(enumeration="cim_1_5.TimeMappingType_enumeration",open=True)
    mappingType.help_text = "Enumerates the different ways that time can be mapped when transforming from one field to another."
    description = MetadataAtomicField.Factory("textfield",blank=True)

    def __init__(self,*args,**kwargs):
        super(TimeTransformation,self).__init__(*args,**kwargs)


class CouplingEndPoint(MetadataModel):
    _name = "CouplingEndPoint"
    _title = "Coupling End Point"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}


    #dataSource = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    dataSource = MetadataManyToOneField(targetModel="cim_1_5.DataObject",sourceModel="cim_1_5.Coupling",addMode=FieldAddModes.REMOTE)
    # TODO: THIS SHOULD BE AN "IDENTIFIER" CLASS
    instanceID = MetadataAtomicField.Factory("charfield",max_length=LIL_STRING,blank=True)
    instanceID.help_text = "If the same datasource is used more than once in a coupled model then a method for identifying which particular instance is being referenced is needed (for BFG)."

    def __init__(self,*args,**kwargs):
        super(CouplingEndPoint,self).__init__(*args,**kwargs)

class Coupling(MetadataModel):
    _name = "Coupling"
    _title = "Coupling"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    purpose = MetadataEnumerationField(enumeration="cim_1_5.DataPurpose_enumeration",open=True)
    fullySpecified = MetadataAtomicField.Factory("booleanfield")
    fullySpecified.help_text="If \"true\" then the coupling is fully-specified.  If \"false\" then not every Connection has been described within the coupling."
    description = MetadataAtomicField.Factory("textfield",blank=True)
    description.help_text="A free-text description of the coupling"
    connectionType = MetadataEnumerationField(enumeration="cim_1_5.ConnectionType_enumeration",open=True)
    connectionType.help_text="Describes the method of coupling"
    timeProfile = MetadataManyToOneField(targetModel="cim_1_5.Timing",sourceModel="cim_1_5.Coupling",addMode=FieldAddModes.INLINE)
    timeProfile.help_text="Describes how often the coupling takes place."
    timeLag = MetadataManyToOneField(targetModel="cim_1_5.TimeLag",sourceModel="cim_1_5.Coupling",addMode=FieldAddModes.INLINE)
    timeLag.help_text="The coupling field used in the target at a given time corresponds to a field produced by the source at a previous time."
    spatialRegridding = MetadataManyToManyField(targetModel="cim_1_5.SpatialRegridding",sourceModel="cim_1_5.Coupling")
    spatialRegridding.help_text="Characteristics of the scheme used to interpolate a field from one grid (source grid) to another (target grid)"
    timeTransformation = MetadataManyToOneField(targetModel="cim_1_5.TimeTransformation",sourceModel="cim_1_5.Coupling",addMode=FieldAddModes.INLINE)
    timeTransformation.help_text="Temporal transformation performed on the coupling field before or after regridding onto the target grid. "
    couplingSource = MetadataManyToOneField(targetModel="cim_1_5.CouplingEndPoint",sourceModel="cim_1_5.CouplingSource",related_name="couplingSource")
    couplingTarget = MetadataManyToOneField(targetModel="cim_1_5.CouplingEndPoint",sourceModel="cim_1_5.CouplingSource",related_name="couplingTarget")
    priming = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    priming.help_text = "A priming source is one that is active on the first available timestep only (before \"proper\" coupling can ocurr).  It can either be described here explicitly, or else a separate coupling/connection with a timing profile that is active on only the first timestep can be created."

    def __init__(self,*args,**kwargs):
        super(Coupling,self).__init__(*args,**kwargs)

    def __unicode__(self):
        name = u'%s' % self.getName()
        if self.connectionType:
            name = u'%s: %s' % (name, self.connectionType)
        return name

class DataObject(DataSource):
    _name = "Coupling"
    _title = "Coupling"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    dataStatus = MetadataEnumerationField(enumeration="cim_1_5.DataStatusType_enumeration",open=False,blank=True)
    dataStatus.help_text = "The current status of the data - is it complete, or is this metadata description all that is available, or is the data continuously supplemented."
    acronym = MetadataAtomicField.Factory("charfield",max_length=LIL_STRING,blank=False)
    description = MetadataAtomicField.Factory("textfield",blank=True)
    hierarchyLevelName = MetadataEnumerationField(enumeration="cim_1_5.DataHierarchyType_enumeration",open=True,blank=True)
    hierarchyLevelName.help_text = "What level in the data hierarchy (constructed by the self-referential parent/child aggregations) is this DataObject."
    content = MetadataManyToManyField(targetModel="cim_1_5.DataContent",sourceModel="cim_1_5.DataObject",related_name="content")
    extent = MetadataManyToOneField(targetModel="cim_1_5.DataExtent",sourceModel="cim_1_5.DataObject",related_name="extent")
#    citation = MetadataManyToOneField(targetModel="cim_1_5.DataCitation",sourceModel="cim_1_5.DataObject",related_name="citation",blank=True)
    distribution = MetadataManyToOneField(targetModel="cim_1_5.DataDistribution",sourceModel="cim_1_5.DataObject",related_name="distribution")
    restriction = MetadataManyToManyField(targetModel="cim_1_5.DataRestriction",sourceModel="cim_1_5.DataObject",related_name="restriction")

    #storage = MetadataAbstractField(targetModel="cim_1_5.DataStorage",sourceModel="cim_1_5.DataObject",related_name="storage",blank=True)
    #storage.help_text = "Describes the method that the DataObject is stored. An abstract <u>class</u> with specific child classes for each supported method."

#    fileStorage = MetadataForeignKey("FileStorage",related_name="fileStorage",blank=True)
#    dBStorage = MetadataForeignKey("DBStorage",related_name="dBStorage",blank=True)
#    iPStorage = MetadataForeignKey("IPStorage",related_name="iPStorage",blank=True)
    keyword = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)
    keyword.help_text = "Descriptive keyword used when searching for DataObjects (this is not the same as shortName / longName / description)."
#    childObjects = models.ManyToManyField("self",related_name="childObjects",symmetrical=False,through="SelfRelationship")

    def __init__(self, *args, **kwargs):
        super(DataObject, self).__init__(*args, **kwargs)
        self.registerFieldType(FieldType("BASIC","Basic Properties"),["dataStatus","acronym","description","hierarchyLevelName","citation","keyword"])
        self.registerFieldType(FieldType("CONTENT","Data Content"),["content"])
        self.registerFieldType(FieldType("EXTENT","Data Extent"),["extent"])
        self.registerFieldType(FieldType("ACCESS","Data Access"),["storage","fileStorage","dBStorage","iPStorage","distribution","restriction"])

    def __unicode__(self):
        name = self.getName()
        if self.acronym:
            name = u'%s: %s' % (name, self.acronym)
        return name


class Standard(MetadataModel):
    _name = "Standard"
    _title = "Standard"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    name = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    version = MetadataAtomicField.Factory("charfield",max_length=LIL_STRING,blank=True)
    description = MetadataAtomicField.Factory("textfield",blank=True)

    def __init__(self,*args,**kwargs):
        super(Standard,self).__init__(*args,**kwargs)

    def __unicode__(self):
        name = self.getName()
        if self.name:
            name = u'%s: %s' % (name, self.name)
        return name

class StandardName(MetadataModel):
    _name = "StandardName"
    _title = "Standard Name"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    value = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    standard = MetadataManyToManyField(targetModel="cim_1_5.Standard",sourceModel="cim_1_5.StandardName",related_name="standard")

    def __init__(self,*args,**kwargs):
        super(StandardName,self).__init__(*args,**kwargs)

class DataTopic(MetadataModel):
    _name = "DataTopic"
    _title = "Data Topic"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    name = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    standardName = MetadataManyToOneField(targetModel="cim_1_5.StandardName",sourceModel="cim_1_5.DataTopic",related_name="standardName",blank=False)
    description = MetadataAtomicField.Factory("textfield",blank=True)
    unit = MetadataEnumerationField(enumeration="cim_1_5.UnitType_enumeration",open=True)

    def __init__(self, *args, **kwargs):
        super(DataTopic, self).__init__(*args, **kwargs)

class DataCitation(MetadataModel):
    _name = "DataCitation"
    _title = "Data Citation"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}


    abstract = MetadataAtomicField.Factory("textfield",blank=True)
#    citation = MetadataManyToOneField(targetModel="cim_1_5.Citation",sourceModel="cim_1_5.DataCitation",related_name="citation",blank=False)

    def __init__(self, *args, **kwargs):
        super(DataCitation, self).__init__(*args, **kwargs)

    def __unicode__(self):
        name = self.getTitle()
        return name

class DataContent(MetadataModel):
    _name = "DataContent"
    _title = "Data Content"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}


    topic = MetadataManyToOneField(targetModel="cim_1_5.DataTopic",sourceModel="cim_1_5.DataContent",related_name="topic",blank=False)
    aggregation = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)
    aggregation.help_text = "Describes how the content has been aggregated together: sum, min, mean, max, ..."
    frequency = MetadataEnumerationField(enumeration="cim_1_5.FrequencyType_enumeration",open=True)
    frequency.help_text = "Describes the frequency of the data content: daily, hourly, ..."
    citation = MetadataManyToManyField(targetModel="cim_1_5.DataCitation",sourceModel="cim_1_5.DataContent",related_name="citation")

    def __init__(self, *args, **kwargs):
        super(DataContent, self).__init__(*args, **kwargs)

    def __unicode__(self):
        name = self.getTitle()
        if self.topic:
            name = u'%s: %s' % (name, self.topic)
        return name

class DataExtent(MetadataModel):

    _name = "DataExtent"
    _title = "Data Extent"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    description = MetadataAtomicField.Factory("charfield",max_length=HUGE_STRING,blank=True)
    geographicElement = MetadataAtomicField.Factory("charfield",max_length=HUGE_STRING,blank=True)
    temporalElement = MetadataAtomicField.Factory("charfield",max_length=HUGE_STRING,blank=True)
    verticalElement = MetadataAtomicField.Factory("charfield",max_length=HUGE_STRING,blank=True)

    def __init__(self, *args, **kwargs):
        super(DataExtent, self).__init__(*args, **kwargs)

class DataDistribution(MetadataModel):

    _name = "DataDistribution"
    _title = "Data Distribution"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    distributionFee = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)
    distributionFormat = MetadataEnumerationField(enumeration="cim_1_5.DataFormatType_enumeration",open=False,blank=True)
    distributionAccess = MetadataEnumerationField(enumeration="cim_1_5.DataAccessType_enumeration",open=False,blank=True)
    responsibleParties = MetadataManyToManyField(targetModel="cim_1_5.ResponsibleParty",sourceModel="cim_1_5.DataDistribution",related_name="responsibleParties")

class License(MetadataModel):
    _name = "License"
    _title = "License"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    unrestricted = MetadataAtomicField.Factory("booleanfield")
    unrestricted.help_text = "If unrestricted=\"true\" then the artifact can be downloaded with no restrictions (ie: there are no administrative steps for the user to deal with; code or data can be downloaded and used directly)."
    unrestricted.enables = ["licenseName","licenseContact","licenseDescription"]
    licenseName = MetadataAtomicField.Factory("charfield",max_length=LIL_STRING,blank=True)
    licenseName.help_text = "The name that the license goes by (ie: 'GPL')"
    licenseContact = MetadataAtomicField.Factory("charfield",max_length=HUGE_STRING,blank=True)
    licenseContact.help_text = "The point of contact for access to this artifact; may be either a person or an institution"
    licenseDescription = MetadataAtomicField.Factory("textfield",blank=True)
    licenseDescription.help_text = "A textual description of the license; might be the full text of the license, more likely to be a brief summary"

    def __unicode__(self):
        name = self.getTitle()
        if self.licenseName:
            name = u'%s: %s' % (name, self.licenseName)
        return name

class DataRestriction(MetadataModel):

   
    _name = "DataRestriction"
    _title = "Data Restriction"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    restrictionScope = MetadataEnumerationField(enumeration="cim_1_5.DataRestrictionScopeType_enumeration",open=False,blank=True)
    # TODO: THIS IS A GMD FIELD
    #restriction =
    license = MetadataManyToOneField(targetModel="cim_1_5.License",sourceModel="cim_1_5.DataRestriction",related_name="license")

    def __unicode__(self):
        name = self.getTitle()
        if self.restrictionScope:
            name = u'%s: %s' % (name, self.restrictionScope)
        if self.license:
            name = u'%s: %s' % (name, self.license)
        return name

class DataStorage(MetadataModel):
    class Meta:
        abstract = True

    _name = "DataStorage"
    _title = "Data Storage"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    dataSize = MetadataAtomicField.Factory("integerfield")
    dataFormat = MetadataEnumerationField(enumeration="cim_1_5.DataFormatType_enumeration",open=False,blank=True)
    dataLocation = MetadataAtomicField.Factory("urlfield")
    modificationDate = MetadataAtomicField.Factory("datefield",null=True)
    modificationDate.help_text = "The date that the file (or other storage medium) has been updated"

    def __init__(self, *args, **kwargs):
        super(DataStorage, self).__init__(*args, **kwargs)

class IPStorage(DataStorage):

    _name = "IPStorage"
    _title = "IP Storage"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    protocol = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)
    host = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)
    path = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)
    fileName = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)

    def __init__(self, *args, **kwargs):
        super(IPStorage, self).__init__(*args, **kwargs)

class FileStorage(DataStorage):

    _name = "FileStorage"
    _title = "File Storage"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    fileSystem = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)
    path = MetadataAtomicField.Factory("charfield",max_length=HUGE_STRING,blank=True)
    fileName = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)

    def __init__(self, *args, **kwargs):
        super(FileStorage, self).__init__(*args, **kwargs)


class DBStorage(DataStorage):

    _name = "DBStorage"
    _title = "Database Storage"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    dbAccessString = MetadataAtomicField.Factory("charfield",max_length=LIL_STRING,blank=True)
    dbName = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    owner = MetadataAtomicField.Factory("charfield",max_length=HUGE_STRING,blank=True)
    dbTable = MetadataAtomicField.Factory("charfield",max_length=HUGE_STRING,blank=True)

    def __init__(self, *args, **kwargs):
        super(DBStorage, self).__init__(*args, **kwargs)

class Conformance(MetadataModel):
    _name = "Conformance"
    _title = "Conformance"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}


    conformant = MetadataAtomicField.Factory("booleanfield")
    conformant.help_text = "Records whether or not this conformance satisfies the requirement.  A simulation should have at least one conformance mapping to every experimental requirement.  If a simulation satisfies the requirement - the usual case - then conformant should have a value of \"true.\"  If conformant is true but there is no reference to a source for the conformance, then we can assume that the simulation conforms to the requirement _naturally_, that is without having to modify code or inputs. If a simulation does not conform to a requirement then conformant should be set to \"false.\""
    type = MetadataEnumerationField(enumeration="cim_1_5.ConformanceType_enumeration",open=False)
    type.help_text = "Describes the method that this simulation conforms to an experimental requirement (in case it is not specified by the change property of the reference to the source of this conformance)"
    description = MetadataAtomicField.Factory("textfield",blank=True)
    frequency = MetadataEnumerationField(enumeration="cim_1_5.FrequencyType_enumeration",open=True)
    # TODO: DOUBLE-CHECK THAT THIS WORKS W/ ABSTRACT CLASSES
    requirements = MetadataManyToManyField(targetModel="cim_1_5.NumericalRequirement",sourceModel="cim_1_5.Conformance",addMode=FieldAddModes.REMOTE)
    requirements.help_text="A NumericalRequirement that the simulation in question is conforming to."
    sources = MetadataManyToManyField(targetModel="cim_1_5.DataSource",sourceModel="cim_1_5.Conformance")
    sources.help_text = "Points to the DataSource used to conform to a particular Requirement.   This may be part of an activity::simulation or a software::component.  It can be either a DataObject or a SoftwareComponent or a ComponentProperty.  It could also be by using particular attributes of, say, a SoftwareComponent, but in that case the recommended practise is to reference the component and add appropriate text in the conformance description attribute."

    def __init__(self,*args,**kwargs):
        super(Conformance,self).__init__(*args,**kwargs)
        self.registerFieldType(FieldType("BASIC","Basic Properties"), ["conformant","type","description","frequency"])
        self.registerFieldType(FieldType("REQUIREMENTS","Experimental Requirements"), ["requirements"])
        self.registerFieldType(FieldType("SOURCES","Conformant Methods"), ["sources"])
        # TECHNICALLY, THIS SHOULDN'T BE HERE
        # BUT IT SEEMS LIKE SUCH AN OBVIOUS CUSTOMIZATION PROJECTS WOULD WANT
        self.setFieldTypeOrder([
            "BASIC","REQUIREMENTS","SOURCES"
        ])

    def __unicode__(self):
        name = u'%s' % self.getName()
        # TODO: map requirements and sources to (truncated) lists
##        if self.requirements:
##            name = u'%s: %s' % (name, "requirements")
##        if self.sources:
##            name = u'%s: %s' % (name, "sources")
        return name


class NumericalActivity(Activity):
    class Meta:
        abstract = True

    _name = "NumericalActivity"
    _title = "Numerical Activity"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    shortName = MetadataAtomicField.Factory("charfield",max_length=LIL_STRING,blank=False)
    longName = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    description = MetadataAtomicField.Factory("textfield",blank=True)

    def __init__(self, *args, **kwargs):
        super(NumericalActivity, self).__init__(*args, **kwargs)
        self.registerFieldType(FieldType("SIMULATION_DESCRIPTION","Simulation Description"),["shortName","longName","description"])

class Simulation(NumericalActivity):
    class Meta:
        abstract = True

    _name = "Simulation"
    _title = "Simulation"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    simulationID = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    calendar = MetadataManyToOneField(targetModel="cim_1_5.Calendar",sourceModel="cim_1_5.Simulation")

    inputs = MetadataManyToManyField(targetModel="cim_1_5.Coupling",sourceModel="cim_1_5.Simulation",addMode=FieldAddModes.INLINE)
    inputs.help_text="implemented as a mapping from a source to target; can be a forcing file, a boundary condition, etc."

    outputs = MetadataManyToManyField(targetModel="cim_1_5.DataObject",sourceModel="cim_1_5.Simulation",related_name="outputs")

    restarts = MetadataManyToManyField(targetModel="cim_1_5.DataObject",sourceModel="cim_1_5.Simulation",related_name="restarts")

    conformances = MetadataManyToManyField(targetModel="cim_1_5.Conformance",sourceModel="cim_1_5.Simulation",addMode=FieldAddModes.INLINE)

    def __init__(self,*args,**kwargs):
        super(Simulation,self).__init__(*args,**kwargs)
        self.registerFieldType(FieldType("SIMULATION_DESCRIPTION","Simulation Description"), ["simulationID","project","rationale"])
        self.registerFieldType(FieldType("BASIC","Basic Properties"), ["calendar"])
        self.registerFieldType(FieldType("COUPLINGS","Inputs & Outputs"),["inputs","outputs","restarts"])
        self.registerFieldType(FieldType("CONFORMANCES","Conformances"), ["conformances"])

class SimulationRun(Simulation):
    _name = "SimulationRun"
    _title = "Simulation Run"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}


    pass

    def __init__(self,*args,**kwargs):
        super(SimulationRun,self).__init__(*args,**kwargs)



class ComponentLanguage(MetadataModel):

    _name = "ComponentLanguage"
    _title = "Component Language"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    name = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    # TODO: PROPERTIES
    #componentLanguageProperty = MetadataPropertyField(property=ComponentLanguage_property)


    def __init__(self,*args,**kwargs):
        super(ComponentLanguage, self).__init__(*args, **kwargs)


class SoftwareComponent(DataSource):
    class Meta:
        abstract = True

    _name = "SoftwareComponent"
    _title = "Software Component"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}


    embedded = MetadataAtomicField.Factory("booleanfield",blank=True)
    embedded.help_text = "An embedded component cannot exist on its own as an atomic piece of software; instead it is embedded within another (parent) component. When embedded equals 'true', the SoftwareComponent has a corresponding piece of software (otherwise it is acting as a 'virtual' component which may be inexorably nested within a piece of software along with several other virtual components)."
    couplingFramework = MetadataEnumerationField(enumeration="cim_1_5.CouplingFrameworkType_enumeration",open=True)
    couplingFramework.help_text = "The coupling framework that this entire component conforms to"
    shortName =  MetadataAtomicField.Factory("charfield",max_length=LIL_STRING,blank=False)
    shortName.help_text = "the name of the model that is used internally"
    longName = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    longName.help_text = "the name of the model that is used externally"
    description = MetadataAtomicField.Factory("textfield",blank=True)
    description.help_text = "a free-text description of the component"
    license = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)
    license.help_text = "the license held by this piece of software"
    # TODO: PROPERTIES (componentProperties, scientificProperties, numericalProperties)
    responsibleParties = MetadataManyToManyField(targetModel='cim_1_5.ResponsibleParty',sourceModel="cim_1_5.SoftwareComponent")
    releaseDate = MetadataAtomicField.Factory("datefield",null=True)
    releaseDate.help_text = "The date of publication of the software component code (as opposed to the date of publication of the metadata document, or the date of deployment of the model)"
    previousVersion = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)
    fundingSource = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)
    fundingSource.help_text = "The entities that funded this software component"
    citations = MetadataManyToManyField(targetModel="cim_1_5.Citation",sourceModel="cim_1_5.SoftwareComponent")

    onlineResource = MetadataAtomicField.Factory("urlfield")

    #componentLanguage = MetadataForeignKey("ComponentLanguage",related_name="componentLanguage")
    componentLanguage = MetadataEnumerationField(enumeration="cim_1_5.ComponentLanguageType_enumeration",open=True)

    def __init__(self,*args,**kwargs):
        super(SoftwareComponent, self).__init__(*args, **kwargs)
        self.registerFieldType(FieldType("BASIC","Basic Properties"),["couplingFramework","license","releaseDate","componentLanguage","citations", "onlineResource","fundingSource","previousVersion","responsibleParties"])
        self.registerFieldType(FieldType("MODEL_DESCRIPTION","Component Description"),["shortName","longName","description", "embedded",])


class ResponsibleParty(MetadataModel):
    _name = "ResponsibleParty"
    _title = "Responsible Party"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    individualName = MetadataAtomicField.Factory("charfield",max_length=LIL_STRING,blank=False)
    organizationName = MetadataAtomicField.Factory("charfield",max_length=LIL_STRING,blank=False)
    role = MetadataEnumerationField(enumeration="cim_1_5.ResponsiblePartyRole_enumeration",open=True,blank=True)

    positionName = MetadataAtomicField.Factory("charfield",max_length=LIL_STRING,blank=True)
    contactInfo = MetadataAtomicField.Factory("charfield",max_length=LIL_STRING,blank=True)

    def __init__(self,*args,**kwargs):
        super(ResponsibleParty,self).__init__(*args,**kwargs)

    def __unicode__(self):
        name = pretty_string(u'%s' % self.getName())
        if self.role:
            name = u'%s: %s' % (name, self.role.strip().rstrip("|").rstrip("|"))
            if self.individualName:
                name = u'%s: %s' % (name, self.individualName)
        else:
            name = u'New %s' % name
        return name

class Citation(MetadataModel):
    _name = "Citation"
    _title = "Reference"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}


    title = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    alternateTitle = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)
    edition = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)
    editionDate = MetadataAtomicField.Factory("datefield",blank=True,null=True)
    identifier = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)
  #  citedResponsibleParty = MetadataManyToManyField('ResponsibleParty',related_name="citedResponsibleParty")
    otherCitationDetails = MetadataAtomicField.Factory("textfield",blank=True)
    collectiveTitle = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)
    isbn = MetadataAtomicField.Factory("charfield",max_length=LIL_STRING,blank=True)
    issn = MetadataAtomicField.Factory("charfield",max_length=LIL_STRING,blank=True)

    def __init__(self,*args,**kwargs):
        super(Citation,self).__init__(*args,**kwargs)

    def __unicode__(self):
        return u'%s: %s' % (self.getTitle(), self.title)

class Timing(MetadataModel):
    _name = "Timing"
    _title = "Timing"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    units = MetadataEnumerationField(enumeration="cim_1_5.TimingUnits_enumeration",open=False)
    variableRate = MetadataAtomicField.Factory("booleanfield",blank=True)
    start = MetadataAtomicField.Factory("datetimefield",blank=True,null=True)
    end = MetadataAtomicField.Factory("datetimefield",blank=True,null=True)
    rate = MetadataAtomicField.Factory("integerfield",blank=True,null=True)

    def __init__(self,*args,**kwargs):
        super(Timing,self).__init__(*args,**kwargs)

class TimeLag(MetadataModel):
    _name = "TimeLag"
    _title = "Time Lag"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    units = MetadataEnumerationField(enumeration="cim_1_5.TimingUnits_enumeration",open=False)
    value = MetadataAtomicField.Factory("integerfield")

    def __init__(self,*args,**kwargs):
        super(TimeLag,self).__init__(*args,**kwargs)

class SpatialRegriddingUserMethod(MetadataModel):
    _name = "SpatialRegriddingUserMethod"
    _title = "Spatial Regridding User Method"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    name = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    file = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=True)

    def __init__(self,*args,**kwargs):
        super(SpatialRegriddingUserMethod,self).__init__(*args,**kwargs)

class SpatialRegridding(MetadataModel):
    _name = "SpatialRegridding"
    _title = "Spatial Regridding"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    spatialRegriddingDimension = MetadataEnumerationField(enumeration="cim_1_5.SpatialRegriddingDimensionType_enumeration",open=False,blank=True)
    spatialRegriddingStandardMethod = MetadataEnumerationField(enumeration="cim_1_5.SpatialRegriddingStandardMethodType_enumeration",open=False)
    spatialRegriddingUserMethod = MetadataManyToOneField(targetModel="cim_1_5.SpatialRegriddingUserMethod",sourceModel="cim_1_5.SpatialRegridding",addMode=FieldAddModes.INLINE)
    spatialRegriddingUserMethod.help_text = "Allows users to bypass the SpatialRegriddingStandardMethod and instead provide a set of weights and addresses for regridding via a file."

    def __init__(self,*args,**kwargs):
        super(SpatialRegridding,self).__init__(*args,**kwargs)

    def __unicode__(self):
        name = u'%s' % self.getName()
        if self.spatialRegriddingDimension:
            name = u'%s: %s' % (name, self.spatialRegriddingDimension)
        if self.spatialRegriddingStandardMethod:
            name = u'%s: %s' % (name, self.spatialRegriddingStandardMethod)
        elif self.spatialRegriddingUserMethod:
            name = u'%s: %s' % (name, self.spatialRegriddingUserMethod)
        return name

class ModelComponent(SoftwareComponent):
    _name = "ModelComponent"
    _title = "Model Component"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}


    type = MetadataEnumerationField(enumeration="cim_1_5.ModelComponentType_enumeration",open=True,readonly=False)
    timing = MetadataManyToOneField(targetModel="cim_1_5.Timing",sourceModel="cim_1_5.ModelComponent",blank=False)
    timing.help_text = "Describes information about how this component simulates time."

    def __init__(self,*args,**kwargs):
        super(ModelComponent,self).__init__(*args,**kwargs)
        self.registerFieldType(FieldType("MODEL_DESCRIPTION","Component Description"), ["type"])
        self.registerFieldType(FieldType("BASIC","Basic Properties"), ["timing"])

class GridMosaic(MetadataModel):
    _name = "GridMosaic"
    _title = "Grid Mosaic"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}


    congruentTiles = MetadataAtomicField.Factory("booleanfield")
    gridMosaic = MetadataManyToManyField(targetModel="cim_1_5.GridMosaic",sourceModel="cim_1_5.GridMosaic",symmetrical=False)
    #gridMosaic = MetadataManyToManyField("GridMosaic",related_name="asdf",recursive=False)

    def __init__(self,*args,**kwargs):
        super(GridMosaic,self).__init__(*args,**kwargs)


class HorizontalGrid(MetadataModel):
    _name = "HorizontalGrid"
    _title = "Horizontal Grid"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    longName = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)

    gridMnemonic = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    gridDiscretization = MetadataEnumerationField(enumeration="cim_1_5.HorizontalGridDiscretizationType_enumeration",open=True,nullable=True)
    gridDiscretization.enables({
        "spherical harmonics" : ["spectralTruncatureNumber",],
        "composite" : ["compositeGridDiscretization","compositeGridType","compositeGrid"],
        "logically rectangular" : ["logicallyRectangularGridType"],
        "structured triangular" : ["structuredTriangularGridType"],
        "unstructured polygonal" : ["unstructuredPolygonalGridType"],
    })
    gridResolution = MetadataAtomicField.Factory("charfield",blank=True)
    gridRefinementScheme = MetadataAtomicField.Factory("charfield",blank=True)
    spectralTruncatureNumber = MetadataAtomicField.Factory("charfield",blank=True)
    compositeGridDiscretization = MetadataEnumerationField(enumeration="cim_1_5.HorizontalGridDiscretizationType_enumeration",open=True,nullable=False,multi=True)    
    compositeGrid = MetadataAtomicField.Factory("charfield",blank=True)
    compositeGridType = MetadataEnumerationField(enumeration="cim_1_5.CompositeGridType_enumeration",open=True,nullable=False,multi=False)
    compositeGridType.verbose_name = "Grid Type"
    compositeGridType.enables({
        "icosohedral" : ["numberOfGridCellsInFirstDimensionOfDiamond","numberOfGridCellsInSecondDimensionOfDiamond","firstPoleLat","firstPoleLon","secondPoleLat","secondPoleLon",],
        "yin yang" : ["numberOfCellsInFirstTileDimension","numberOfCellsInSecondTileDimension"]
    })
    logicallyRectangularGridType = MetadataEnumerationField(enumeration="cim_1_5.LogicallyRectangularGridType_enumeration",open=True,nullable=False,multi=False)
    logicallyRectangularGridType.verbose_name = "Grid Type"
    logicallyRectangularGridType.enables({
        "latitude-longitude" : ["numberOfLongitudinalGridCells","numberOfLatitudinalGridCells"],
        "regular gaussian" : ["numberOfLongitudinalGridPoints","numberOfLatitudePointsPoleToEquator"],
        "cubed sphere" : ["numberOfCellsInFirstGridDimension","numberOfCellsInSecondGridDimension"],
        "tripolar" : ["numberOfCellsInFirstGridDimension","numberOfCellsInSecondGridDimension","firstPoleLat","firstPoleLon","secondPoleLat","secondPoleLon","thirdPoleLat","thirdPoleLon",]
    })
    structuredTriangularGridType = MetadataEnumerationField(enumeration="cim_1_5.StructuredTriangularGridType",open=True,nullable=False,multi=False)
    structuredTriangularGridType.verbose_name = "Grid Type"
    compositeGridType.enables({
        "icosohedral" : ["numberOfGridCellsInFirstDimensionOfDiamond","numberOfGridCellsInSecondDimensionOfDiamond","firstPoleLat","firstPoleLon","secondPoleLat","secondPoleLon",],
    })
    unstructuredPolygonalGridType = MetadataEnumerationField(enumeration="cim_1_5.UnstructuredPolygonalGridType_enumeration",open=True,nullable=False,multi=False)
    unstructuredPolygonalGridType.verbose_name = "Grid Type"
    unstructuredPolygonalGridType.enables({
        "reduced gaussian" : ["numberOfTotalGridPoints","firstPoleLat","firstPoleLon","secondPoleLat","secondPoleLon","numberOfCellsInFirstGridDimension","numberOfCellsInSecondGridDimension"]
    })
    numberOfLongitudinalGridCells = MetadataAtomicField.Factory("charfield",blank=True)
    numberOfLatitudinalGridCells = MetadataAtomicField.Factory("charfield",blank=True)
    numberOfLongitudinalGridPoints= MetadataAtomicField.Factory("charfield",blank=True)
    numberOfLatitudePointsPoleToEquator = MetadataAtomicField.Factory("charfield",blank=True)
    numberOfTotalGridPoints = MetadataAtomicField.Factory("charfield",blank=True)
    firstPoleLat = MetadataAtomicField.Factory("charfield",blank=True)
    firstPoleLon = MetadataAtomicField.Factory("charfield",blank=True)
    secondPoleLat = MetadataAtomicField.Factory("charfield",blank=True)
    secondPoleLon = MetadataAtomicField.Factory("charfield",blank=True)
    thirdPoleLat = MetadataAtomicField.Factory("charfield",blank=True)
    thirdPoleLon = MetadataAtomicField.Factory("charfield",blank=True)
    numberOfCellsInFirstGridDimension = MetadataAtomicField.Factory("charfield",blank=True)
    numberOfCellsInSecondGridDimension = MetadataAtomicField.Factory("charfield",blank=True)
    numberOfGridCellsInFirstDimensionOfDiamond = MetadataAtomicField.Factory("charfield",blank=True)
    numberOfGridCellsInSecondDimensionOfDiamond = MetadataAtomicField.Factory("charfield",blank=True)
    numberOfCellsInFirstTileDimension = MetadataAtomicField.Factory("charfield",blank=True)
    numberOfCellsInSecondTileDimension = MetadataAtomicField.Factory("charfield",blank=True)

    latMin = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    latMax = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    lonMin = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    lonMax = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)

    def __init__(self,*args,**kwargs):
        super(HorizontalGrid,self).__init__(*args,**kwargs)
        self.registerFieldType(FieldType("EXTENT","Horizontal Extent"),["latMin","latMax","lonMin","lonMax"])
        self.registerFieldType(FieldType("BASIC","General Attributes"),[
            "longName","gridMnemonic","gridDiscretization","gridResolution","gridRefinementScheme","spectralTruncatureNumber",
            "compositeGridDiscretization","compositeGrid","compositeGridType",
            "logicallyRectangularGridType",
            "structuredTriangularGridType",
            "unstructuredPolygonalGridType",
            "numberOfLongitudinalGridCells","numberOfLatitudinalGridCells",
            "numberOfLongitudinalGridPoints","numberOfLatitudePointsPoleToEquator",
            "numberOfTotalGridPoints","firstPoleLat","firstPoleLon","secondPoleLat","secondPoleLon","numberOfCellsInFirstGridDimension","numberOfCellsInSecondGridDimension",
            "numberOfGridCellsInFirstDimensionOfDiamond","numberOfGridCellsInSecondDimensionOfDiamond",
            "thirdPoleLat","thirdPoleLon",
            "numberOfCellsInFirstTileDimension","numberOfCellsInSecondTileDimension"
        ])
        self.setFieldTypeOrder(["BASIC","EXTENT"])




class VerticalGrid(MetadataModel):
    _name = "VerticalGrid"
    _title = "Vertical Grid"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    longName = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)

    domain = MetadataEnumerationField(enumeration="cim_1_5.VerticalGridDomain_enumeration",open=True,nullable=True)
    domain.enables({
        "atmospheric" : ["numberOAtmosphericfLevels","topAtmosphericModelLevel","numberOfAtmosphericLevelsBelow850hPa","numberOfAtmosphericLevelsAbove200hPa",],
        "oceanic" : ["numberOfOceanicLevels",],
    })

    #TODO: domain should be an enabler: atmospheric=>the next 4 fields, oceanic=>the 4 fields after that

    numberOfAtmosphericLevels = MetadataAtomicField.Factory("integerfield",blank=True)
    numberOfAtmosphericLevels.verbose_name = "Number of Levels"
    topAtmosphericModelLevel = MetadataAtomicField.Factory("charfield",max_length=HUGE_STRING,blank=True)
    topAtmosphericModelLevel.verbose_name = "Top Model Level"
    numberOfAtmosphericLevelsBelow850hPa = MetadataAtomicField.Factory("integerfield",blank=True)
    numberOfAtmosphericLevelsBelow850hPa.verboseName = "Number of Levels Below 850hPa"
    numberOfAtmosphericLevelsAbove200hPa = MetadataAtomicField.Factory("integerfield",blank=True)
    numberOfAtmosphericLevelsAbove200hPa.verboseName = "Number of Levels Above 200hPa"

    numberOfOceanicLevels = MetadataAtomicField.Factory("integerfield",blank=True)
    numberOfOceanicLevels.verbose_name = "Number of (Oceanic) Levels"

    def __init__(self,*args,**kwargs):
        super(VerticalGrid,self).__init__(*args,**kwargs)
        self.registerFieldType(FieldType("EXTENT","Vertical Extent"),["domain","numberOfAtmosphericLevels","topAtmosphericModelLevel","numberOfAtmosphericLevelsBelow850hPa","numberOfAtmosphericLevelsAbove200hPa","numberOfOceanicLevels",])
        self.registerFieldType(FieldType("BASIC","General Attributes"),["longName",])
        self.setFieldTypeOrder(["BASIC","EXTENT"])

class GridSpec(MetadataModel):
    _name = "GridSpec"
    _title = "Grid"
    _fieldTypes = {}
    _fieldTypeOrder = None
    _fieldOrder = None
    _initialValues = {}

    shortName = MetadataAtomicField.Factory("charfield",max_length=LIL_STRING,blank=False)
    longName = MetadataAtomicField.Factory("charfield",max_length=BIG_STRING,blank=False)
    description = MetadataAtomicField.Factory("textfield",blank=True)
    gridType = MetadataEnumerationField(enumeration="cim_1_5.GridType_enumeration",open=True,blank=False)

    #esmModelGrids = MetadataManyToManyField(targetModel="cim_1_5.GridMosaic",sourceModel="cim_1_5.GridSpec")
    # TODO: I AM BASING THIS ON THE QNAIRE FOR NOW...
    horizontalGrid = MetadataManyToOneField(targetModel="cim_1_5.HorizontalGrid",sourceModel="cim_1_5.GridSpec")
    horizontalGrid.addMode = FieldAddModes.REMOTE

    verticalGrid = MetadataManyToOneField(targetModel="cim_1_5.VerticalGrid",sourceModel="cim_1_5.GridSpec")
    verticalGrid.addMode = FieldAddModes.REMOTE

    def __init__(self,*args,**kwargs):
        super(GridSpec,self).__init__(*args,**kwargs)
        self.registerFieldType(FieldType("GRID_DESCRIPTION","Grid Description"),["shortName","longName","gridType","description",])
        self.registerFieldType(FieldType("VERTICAL_GRID","Vertical Grid Details"),["verticalGrid",])
        self.registerFieldType(FieldType("HORIZONTAL_GRID","Horizontal Grid Details"),["horizontalGrid",])

        
        
